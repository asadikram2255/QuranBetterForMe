{
  "cells": [
    {
      "cell_type": "markdown",
      "id": "8a0067d2",
      "metadata": {
        "id": "8a0067d2"
      },
      "source": [
        "# Qur'an Semantic Search — End-to-End Builder (Ready-to-Run)\n",
        "**Purpose:** Rebuild `links.json`, `links_cosine.json`, `links_bm25.json` reliably for the HTML viewer.\n",
        "\n",
        "Run all cells **top to bottom**. If you are in Google Colab, keep your Drive mounted.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "20120190",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "20120190",
        "outputId": "69ebd59c-c445-4679-cc75-44a713f02107"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Mounted at /content/drive\n",
            "✅ Colab detected; Drive mounted.\n",
            "DATA_DIR = /content/drive/My Drive/999. MS/10. Project/quran_semantic_data\n"
          ]
        }
      ],
      "source": [
        "# ==== Cell 1 — Environment & Paths (GitHub-friendly) ====\n",
        "import sys, subprocess, os, json, re, datetime\n",
        "from pathlib import Path\n",
        "\n",
        "# Project root = current working directory when run\n",
        "ROOT = Path.cwd()\n",
        "\n",
        "# Use repo-relative folders\n",
        "DATA_DIR     = ROOT / \"data\"\n",
        "ART_DIR      = ROOT / \"artifacts\"\n",
        "DATA_DIR.mkdir(parents=True, exist_ok=True)\n",
        "ART_DIR.mkdir(parents=True, exist_ok=True)\n",
        "\n",
        "# Key files\n",
        "QURAN_CSV    = DATA_DIR / \"quran.csv\"\n",
        "QURAN_XML    = DATA_DIR / \"quran-simple.xml\"   # optional fallback if you add it later\n",
        "EMB_PATH     = DATA_DIR / \"embeddings_e5_small.npy\"   # cached embeddings (small; safe in Git)\n",
        "LINKS_HYBRID = ART_DIR / \"links.json\"\n",
        "LINKS_COSINE = ART_DIR / \"links_cosine.json\"\n",
        "LINKS_BM25   = ART_DIR / \"links_bm25.json\"\n",
        "\n",
        "# Retrieval config\n",
        "ALPHA           = 0.8\n",
        "TOP_K           = 20\n",
        "GENERATE_LIMIT  = None  # e.g. 500 for a quick run; None = all\n",
        "\n",
        "def ensure(pkg, import_name=None, version=None):\n",
        "    import importlib, subprocess, sys\n",
        "    name = import_name or pkg\n",
        "    try:\n",
        "        importlib.import_module(name); return\n",
        "    except Exception:\n",
        "        args = [sys.executable, \"-m\", \"pip\", \"install\", \"--no-cache-dir\", \"--upgrade\"]\n",
        "        args.append(f\"{pkg}=={version}\" if version else pkg)\n",
        "        print(\"> pip\", \" \".join(args[3:]))\n",
        "        subprocess.check_call(args)\n",
        "        importlib.invalidate_caches()\n",
        "        importlib.import_module(name)\n",
        "\n",
        "print(\"DATA_DIR =\", DATA_DIR)\n",
        "print(\"ART_DIR  =\", ART_DIR)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "80fcb961",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "80fcb961",
        "outputId": "353410c6-6d73-4e3d-d69a-6a6f8eb4af6a"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m184.4/184.4 MB\u001b[0m \u001b[31m149.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m1.9/1.9 MB\u001b[0m \u001b[31m155.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m495.6/495.6 kB\u001b[0m \u001b[31m151.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m171.5/171.5 kB\u001b[0m \u001b[31m9.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m324.4/324.4 kB\u001b[0m \u001b[31m29.1 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m434.8/434.8 kB\u001b[0m \u001b[31m348.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h✅ Imports ready.\n"
          ]
        }
      ],
      "source": [
        "# ============================================================\n",
        "# Cell 2 — Minimal stack & imports (Py3.12 safe)\n",
        "#  * Numeric/data basics\n",
        "#  * BM25\n",
        "#  * HF + Torch stack (CPU) with compatible pins\n",
        "# ============================================================\n",
        "# Numeric / data\n",
        "ensure(\"numpy\", version=\"2.1.3\")\n",
        "ensure(\"pandas\", version=\"2.2.3\")\n",
        "ensure(\"scikit-learn\", import_name=\"sklearn\", version=\"1.5.2\")\n",
        "\n",
        "# rank-bm25 (install separately to avoid resolver hiccups)\n",
        "try:\n",
        "    import rank_bm25\n",
        "except ImportError:\n",
        "    # separate install avoids conflicts\n",
        "    get_ipython().system(\"pip install --no-cache-dir rank-bm25==0.2.2 -q\")\n",
        "    import rank_bm25\n",
        "\n",
        "# Torch + HF stack (CPU-only)\n",
        "get_ipython().system(\"pip install --no-cache-dir --upgrade torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu -q\")\n",
        "get_ipython().system(\"pip install --no-cache-dir --upgrade sentence-transformers==2.7.0 transformers==4.57.1 tokenizers==0.22.1 huggingface-hub==0.36.0 accelerate==0.34.2 safetensors==0.4.5 -q\")\n",
        "\n",
        "# Imports\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "from rank_bm25 import BM25Okapi\n",
        "from sentence_transformers import SentenceTransformer\n",
        "try:\n",
        "    from tqdm import tqdm\n",
        "except Exception:\n",
        "    tqdm = lambda x, **k: x  # fallback\n",
        "print(\"✅ Imports ready.\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "c3305f96",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 161
        },
        "id": "c3305f96",
        "outputId": "89371961-105b-4430-8a88-1d10630f39d4"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Loaded verses: 6236\n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "   surah  ayah                              arabic_text  key  \\\n",
              "0      1     1  بِسْمِ اللَّهِ الرَّحْمَـٰنِ الرَّحِيمِ  1:1   \n",
              "1      1     2    الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ  1:2   \n",
              "2      1     3                 الرَّحْمَـٰنِ الرَّحِيمِ  1:3   \n",
              "\n",
              "                      norm  \n",
              "0  بسم الله الرحمٰن الرحيم  \n",
              "1    الحمد لله رب العالمين  \n",
              "2           الرحمٰن الرحيم  "
            ],
            "text/html": [
              "\n",
              "  <div id=\"df-46c36fe8-a210-461b-bbf8-b9065738fa91\" class=\"colab-df-container\">\n",
              "    <div>\n",
              "<style scoped>\n",
              "    .dataframe tbody tr th:only-of-type {\n",
              "        vertical-align: middle;\n",
              "    }\n",
              "\n",
              "    .dataframe tbody tr th {\n",
              "        vertical-align: top;\n",
              "    }\n",
              "\n",
              "    .dataframe thead th {\n",
              "        text-align: right;\n",
              "    }\n",
              "</style>\n",
              "<table border=\"1\" class=\"dataframe\">\n",
              "  <thead>\n",
              "    <tr style=\"text-align: right;\">\n",
              "      <th></th>\n",
              "      <th>surah</th>\n",
              "      <th>ayah</th>\n",
              "      <th>arabic_text</th>\n",
              "      <th>key</th>\n",
              "      <th>norm</th>\n",
              "    </tr>\n",
              "  </thead>\n",
              "  <tbody>\n",
              "    <tr>\n",
              "      <th>0</th>\n",
              "      <td>1</td>\n",
              "      <td>1</td>\n",
              "      <td>بِسْمِ اللَّهِ الرَّحْمَـٰنِ الرَّحِيمِ</td>\n",
              "      <td>1:1</td>\n",
              "      <td>بسم الله الرحمٰن الرحيم</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>1</th>\n",
              "      <td>1</td>\n",
              "      <td>2</td>\n",
              "      <td>الْحَمْدُ لِلَّهِ رَبِّ الْعَالَمِينَ</td>\n",
              "      <td>1:2</td>\n",
              "      <td>الحمد لله رب العالمين</td>\n",
              "    </tr>\n",
              "    <tr>\n",
              "      <th>2</th>\n",
              "      <td>1</td>\n",
              "      <td>3</td>\n",
              "      <td>الرَّحْمَـٰنِ الرَّحِيمِ</td>\n",
              "      <td>1:3</td>\n",
              "      <td>الرحمٰن الرحيم</td>\n",
              "    </tr>\n",
              "  </tbody>\n",
              "</table>\n",
              "</div>\n",
              "    <div class=\"colab-df-buttons\">\n",
              "\n",
              "  <div class=\"colab-df-container\">\n",
              "    <button class=\"colab-df-convert\" onclick=\"convertToInteractive('df-46c36fe8-a210-461b-bbf8-b9065738fa91')\"\n",
              "            title=\"Convert this dataframe to an interactive table.\"\n",
              "            style=\"display:none;\">\n",
              "\n",
              "  <svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\" viewBox=\"0 -960 960 960\">\n",
              "    <path d=\"M120-120v-720h720v720H120Zm60-500h600v-160H180v160Zm220 220h160v-160H400v160Zm0 220h160v-160H400v160ZM180-400h160v-160H180v160Zm440 0h160v-160H620v160ZM180-180h160v-160H180v160Zm440 0h160v-160H620v160Z\"/>\n",
              "  </svg>\n",
              "    </button>\n",
              "\n",
              "  <style>\n",
              "    .colab-df-container {\n",
              "      display:flex;\n",
              "      gap: 12px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert {\n",
              "      background-color: #E8F0FE;\n",
              "      border: none;\n",
              "      border-radius: 50%;\n",
              "      cursor: pointer;\n",
              "      display: none;\n",
              "      fill: #1967D2;\n",
              "      height: 32px;\n",
              "      padding: 0 0 0 0;\n",
              "      width: 32px;\n",
              "    }\n",
              "\n",
              "    .colab-df-convert:hover {\n",
              "      background-color: #E2EBFA;\n",
              "      box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "      fill: #174EA6;\n",
              "    }\n",
              "\n",
              "    .colab-df-buttons div {\n",
              "      margin-bottom: 4px;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert {\n",
              "      background-color: #3B4455;\n",
              "      fill: #D2E3FC;\n",
              "    }\n",
              "\n",
              "    [theme=dark] .colab-df-convert:hover {\n",
              "      background-color: #434B5C;\n",
              "      box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15);\n",
              "      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3));\n",
              "      fill: #FFFFFF;\n",
              "    }\n",
              "  </style>\n",
              "\n",
              "    <script>\n",
              "      const buttonEl =\n",
              "        document.querySelector('#df-46c36fe8-a210-461b-bbf8-b9065738fa91 button.colab-df-convert');\n",
              "      buttonEl.style.display =\n",
              "        google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "\n",
              "      async function convertToInteractive(key) {\n",
              "        const element = document.querySelector('#df-46c36fe8-a210-461b-bbf8-b9065738fa91');\n",
              "        const dataTable =\n",
              "          await google.colab.kernel.invokeFunction('convertToInteractive',\n",
              "                                                    [key], {});\n",
              "        if (!dataTable) return;\n",
              "\n",
              "        const docLinkHtml = 'Like what you see? Visit the ' +\n",
              "          '<a target=\"_blank\" href=https://colab.research.google.com/notebooks/data_table.ipynb>data table notebook</a>'\n",
              "          + ' to learn more about interactive tables.';\n",
              "        element.innerHTML = '';\n",
              "        dataTable['output_type'] = 'display_data';\n",
              "        await google.colab.output.renderOutput(dataTable, element);\n",
              "        const docLink = document.createElement('div');\n",
              "        docLink.innerHTML = docLinkHtml;\n",
              "        element.appendChild(docLink);\n",
              "      }\n",
              "    </script>\n",
              "  </div>\n",
              "\n",
              "\n",
              "    <div id=\"df-221ed662-d4f6-4571-8295-b7f1aa36fe6a\">\n",
              "      <button class=\"colab-df-quickchart\" onclick=\"quickchart('df-221ed662-d4f6-4571-8295-b7f1aa36fe6a')\"\n",
              "                title=\"Suggest charts\"\n",
              "                style=\"display:none;\">\n",
              "\n",
              "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"24px\"viewBox=\"0 0 24 24\"\n",
              "     width=\"24px\">\n",
              "    <g>\n",
              "        <path d=\"M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z\"/>\n",
              "    </g>\n",
              "</svg>\n",
              "      </button>\n",
              "\n",
              "<style>\n",
              "  .colab-df-quickchart {\n",
              "      --bg-color: #E8F0FE;\n",
              "      --fill-color: #1967D2;\n",
              "      --hover-bg-color: #E2EBFA;\n",
              "      --hover-fill-color: #174EA6;\n",
              "      --disabled-fill-color: #AAA;\n",
              "      --disabled-bg-color: #DDD;\n",
              "  }\n",
              "\n",
              "  [theme=dark] .colab-df-quickchart {\n",
              "      --bg-color: #3B4455;\n",
              "      --fill-color: #D2E3FC;\n",
              "      --hover-bg-color: #434B5C;\n",
              "      --hover-fill-color: #FFFFFF;\n",
              "      --disabled-bg-color: #3B4455;\n",
              "      --disabled-fill-color: #666;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart {\n",
              "    background-color: var(--bg-color);\n",
              "    border: none;\n",
              "    border-radius: 50%;\n",
              "    cursor: pointer;\n",
              "    display: none;\n",
              "    fill: var(--fill-color);\n",
              "    height: 32px;\n",
              "    padding: 0;\n",
              "    width: 32px;\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart:hover {\n",
              "    background-color: var(--hover-bg-color);\n",
              "    box-shadow: 0 1px 2px rgba(60, 64, 67, 0.3), 0 1px 3px 1px rgba(60, 64, 67, 0.15);\n",
              "    fill: var(--button-hover-fill-color);\n",
              "  }\n",
              "\n",
              "  .colab-df-quickchart-complete:disabled,\n",
              "  .colab-df-quickchart-complete:disabled:hover {\n",
              "    background-color: var(--disabled-bg-color);\n",
              "    fill: var(--disabled-fill-color);\n",
              "    box-shadow: none;\n",
              "  }\n",
              "\n",
              "  .colab-df-spinner {\n",
              "    border: 2px solid var(--fill-color);\n",
              "    border-color: transparent;\n",
              "    border-bottom-color: var(--fill-color);\n",
              "    animation:\n",
              "      spin 1s steps(1) infinite;\n",
              "  }\n",
              "\n",
              "  @keyframes spin {\n",
              "    0% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "      border-left-color: var(--fill-color);\n",
              "    }\n",
              "    20% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    30% {\n",
              "      border-color: transparent;\n",
              "      border-left-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    40% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-top-color: var(--fill-color);\n",
              "    }\n",
              "    60% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "    }\n",
              "    80% {\n",
              "      border-color: transparent;\n",
              "      border-right-color: var(--fill-color);\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "    90% {\n",
              "      border-color: transparent;\n",
              "      border-bottom-color: var(--fill-color);\n",
              "    }\n",
              "  }\n",
              "</style>\n",
              "\n",
              "      <script>\n",
              "        async function quickchart(key) {\n",
              "          const quickchartButtonEl =\n",
              "            document.querySelector('#' + key + ' button');\n",
              "          quickchartButtonEl.disabled = true;  // To prevent multiple clicks.\n",
              "          quickchartButtonEl.classList.add('colab-df-spinner');\n",
              "          try {\n",
              "            const charts = await google.colab.kernel.invokeFunction(\n",
              "                'suggestCharts', [key], {});\n",
              "          } catch (error) {\n",
              "            console.error('Error during call to suggestCharts:', error);\n",
              "          }\n",
              "          quickchartButtonEl.classList.remove('colab-df-spinner');\n",
              "          quickchartButtonEl.classList.add('colab-df-quickchart-complete');\n",
              "        }\n",
              "        (() => {\n",
              "          let quickchartButtonEl =\n",
              "            document.querySelector('#df-221ed662-d4f6-4571-8295-b7f1aa36fe6a button');\n",
              "          quickchartButtonEl.style.display =\n",
              "            google.colab.kernel.accessAllowed ? 'block' : 'none';\n",
              "        })();\n",
              "      </script>\n",
              "    </div>\n",
              "\n",
              "    </div>\n",
              "  </div>\n"
            ],
            "application/vnd.google.colaboratory.intrinsic+json": {
              "type": "dataframe",
              "variable_name": "df",
              "summary": "{\n  \"name\": \"df\",\n  \"rows\": 6236,\n  \"fields\": [\n    {\n      \"column\": \"surah\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 26,\n        \"min\": 1,\n        \"max\": 114,\n        \"num_unique_values\": 114,\n        \"samples\": [\n          81,\n          5,\n          41\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"ayah\",\n      \"properties\": {\n        \"dtype\": \"number\",\n        \"std\": 50,\n        \"min\": 1,\n        \"max\": 286,\n        \"num_unique_values\": 286,\n        \"samples\": [\n          10,\n          268,\n          144\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"arabic_text\",\n      \"properties\": {\n        \"dtype\": \"string\",\n        \"num_unique_values\": 6060,\n        \"samples\": [\n          \"\\u0641\\u064e\\u0623\\u064e\\u0633\\u0652\\u0631\\u0650 \\u0628\\u0650\\u0639\\u0650\\u0628\\u064e\\u0627\\u062f\\u0650\\u064a \\u0644\\u064e\\u064a\\u0652\\u0644\\u064b\\u0627 \\u0625\\u0650\\u0646\\u0651\\u064e\\u0643\\u064f\\u0645 \\u0645\\u0651\\u064f\\u062a\\u0651\\u064e\\u0628\\u064e\\u0639\\u064f\\u0648\\u0646\\u064e\",\n          \"\\u0648\\u064e\\u0634\\u064e\\u0631\\u064e\\u0648\\u0652\\u0647\\u064f \\u0628\\u0650\\u062b\\u064e\\u0645\\u064e\\u0646\\u064d \\u0628\\u064e\\u062e\\u0652\\u0633\\u064d \\u062f\\u064e\\u0631\\u064e\\u0627\\u0647\\u0650\\u0645\\u064e \\u0645\\u064e\\u0639\\u0652\\u062f\\u064f\\u0648\\u062f\\u064e\\u0629\\u064d \\u0648\\u064e\\u0643\\u064e\\u0627\\u0646\\u064f\\u0648\\u0627 \\u0641\\u0650\\u064a\\u0647\\u0650 \\u0645\\u0650\\u0646\\u064e \\u0627\\u0644\\u0632\\u0651\\u064e\\u0627\\u0647\\u0650\\u062f\\u0650\\u064a\\u0646\\u064e\",\n          \"\\u0648\\u064e\\u0645\\u064e\\u0646 \\u0643\\u064e\\u0627\\u0646\\u064e \\u0641\\u0650\\u064a \\u0647\\u064e\\u0640\\u0670\\u0630\\u0650\\u0647\\u0650 \\u0623\\u064e\\u0639\\u0652\\u0645\\u064e\\u0649\\u0670 \\u0641\\u064e\\u0647\\u064f\\u0648\\u064e \\u0641\\u0650\\u064a \\u0627\\u0644\\u0652\\u0622\\u062e\\u0650\\u0631\\u064e\\u0629\\u0650 \\u0623\\u064e\\u0639\\u0652\\u0645\\u064e\\u0649\\u0670 \\u0648\\u064e\\u0623\\u064e\\u0636\\u064e\\u0644\\u0651\\u064f \\u0633\\u064e\\u0628\\u0650\\u064a\\u0644\\u064b\\u0627\"\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"key\",\n      \"properties\": {\n        \"dtype\": \"string\",\n        \"num_unique_values\": 6236,\n        \"samples\": [\n          \"4:107\",\n          \"15:43\",\n          \"26:176\"\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    },\n    {\n      \"column\": \"norm\",\n      \"properties\": {\n        \"dtype\": \"string\",\n        \"num_unique_values\": 6057,\n        \"samples\": [\n          \"\\u0648\\u0627\\u0645\\u0637\\u0631\\u0646\\u0627 \\u0639\\u0644\\u064a\\u0647\\u0645 \\u0645\\u0637\\u0631\\u0627  \\u0641\\u0627\\u0646\\u0638\\u0631 \\u0643\\u064a\\u0641 \\u0643\\u0627\\u0646 \\u0639\\u0627\\u0642\\u0628\\u0647 \\u0627\\u0644\\u0645\\u062c\\u0631\\u0645\\u064a\\u0646\",\n          \"\\u0627\\u0646 \\u0627\\u0644\\u064a\\u0670 \\u0631\\u0628\\u0643 \\u0627\\u0644\\u0631\\u062c\\u0639\\u064a\\u0670\",\n          \"\\u0642\\u0627\\u0644 \\u0627\\u0644\\u0645\\u0644\\u0627 \\u0645\\u0646 \\u0642\\u0648\\u0645 \\u0641\\u0631\\u0639\\u0648\\u0646 \\u0627\\u0646 \\u0647\\u0670\\u0630\\u0627 \\u0644\\u0633\\u0627\\u062d\\u0631 \\u0639\\u0644\\u064a\\u0645\"\n        ],\n        \"semantic_type\": \"\",\n        \"description\": \"\"\n      }\n    }\n  ]\n}"
            }
          },
          "metadata": {},
          "execution_count": 3
        }
      ],
      "source": [
        "# ============================================================\n",
        "# Cell 3 — Load Qur'an corpus\n",
        "#  * Prefer quran.csv (surah, ayah, arabic_text)\n",
        "#  * Fallback: build from quran-simple.xml (Tanzil)\n",
        "# ============================================================\n",
        "def build_csv_from_tanzil(xml_path: Path, out_csv: Path):\n",
        "    import xml.etree.ElementTree as ET\n",
        "    root = ET.parse(xml_path).getroot()\n",
        "    rows = []\n",
        "    for s in root.iter('sura'):\n",
        "        s_no = int(s.attrib.get('index'))\n",
        "        for a in s.iter('aya'):\n",
        "            a_no = int(a.attrib.get('index'))\n",
        "            text = a.attrib.get('text', '')\n",
        "            rows.append((s_no, a_no, text))\n",
        "    df_ = pd.DataFrame(rows, columns=['surah','ayah','arabic_text'])\n",
        "    df_.to_csv(out_csv, index=False, encoding='utf-8')\n",
        "    print(f\"Built {out_csv} from {xml_path} (rows={len(df_)})\")\n",
        "    return out_csv\n",
        "\n",
        "if not QURAN_CSV.exists():\n",
        "    if QURAN_XML.exists():\n",
        "        print(\"quran.csv not found; building from quran-simple.xml ...\")\n",
        "        build_csv_from_tanzil(QURAN_XML, QURAN_CSV)\n",
        "    else:\n",
        "        raise FileNotFoundError(f\"Missing {QURAN_CSV} (and fallback {QURAN_XML} not present)\")\n",
        "\n",
        "df = pd.read_csv(QURAN_CSV)\n",
        "for col in [\"surah\",\"ayah\",\"arabic_text\"]:\n",
        "    assert col in df.columns, f\"Missing column: {col}\"\n",
        "\n",
        "# Key \"s:a\"\n",
        "df[\"key\"] = df[\"surah\"].astype(int).astype(str) + \":\" + df[\"ayah\"].astype(int).astype(str)\n",
        "\n",
        "# Arabic normalization (lightweight but consistent)\n",
        "_ar_diacritics = re.compile(r\"[\\u0610-\\u061A\\u064B-\\u065F\\u06D6-\\u06ED]\")\n",
        "def normalize_arabic(s: str) -> str:\n",
        "    s = str(s)\n",
        "    s = _ar_diacritics.sub(\"\", s)    # remove diacritics\n",
        "    s = s.replace(\"\\u0640\", \"\")      # tatweel\n",
        "    s = re.sub(\"[إأآ]\", \"ا\", s)      # unify alif forms\n",
        "    s = s.replace(\"ؤ\",\"و\").replace(\"ئ\",\"ي\").replace(\"ى\",\"ي\").replace(\"ة\",\"ه\")\n",
        "    return s\n",
        "\n",
        "\n",
        "df[\"norm\"] = df[\"arabic_text\"].fillna(\"\").map(normalize_arabic)\n",
        "print(\"Loaded verses:\", len(df))\n",
        "df.head(3)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b99d5159",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "b99d5159",
        "outputId": "293b4ddf-e5d0-42f9-82a1-c4980ef9d926"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "BM25 ready: documents = 6236\n"
          ]
        }
      ],
      "source": [
        "# ============================================================\n",
        "# Cell 4 — BM25 baseline\n",
        "#  * Tokenize normalized Arabic and build BM25Okapi\n",
        "# ============================================================\n",
        "def simple_tok(s: str):\n",
        "    return [t for t in re.split(r\"\\W+\", s) if t]\n",
        "\n",
        "corpus_tokens = [simple_tok(t) for t in df[\"norm\"].tolist()]\n",
        "bm25 = BM25Okapi(corpus_tokens)\n",
        "print(\"BM25 ready: documents =\", len(corpus_tokens))\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "e1efd644",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "e1efd644",
        "outputId": "114c434a-57bb-4877-9490-09123c4ce065"
      },
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Loaded embeddings: /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/embeddings_e5_small.npy (6236, 384)\n"
          ]
        }
      ],
      "source": [
        "# ============================================================\n",
        "# Cell 5 — Embeddings\n",
        "#  * Load cached embeddings if present; else compute & save\n",
        "#  * Normalize embeddings so dot = cosine\n",
        "# ============================================================\n",
        "if EMB_PATH.exists():\n",
        "    emb = np.load(EMB_PATH)\n",
        "    assert emb.shape[0] == len(df), f\"Embeddings rows {emb.shape[0]} != verses {len(df)}\"\n",
        "    print(\"Loaded embeddings:\", EMB_PATH, emb.shape)\n",
        "else:\n",
        "    model = SentenceTransformer(\"intfloat/multilingual-e5-small\")\n",
        "    texts = df[\"norm\"].tolist()\n",
        "    emb = model.encode(texts, batch_size=64, normalize_embeddings=True, convert_to_numpy=True)\n",
        "    np.save(EMB_PATH, emb)\n",
        "    print(\"Computed & saved embeddings:\", EMB_PATH, emb.shape)\n",
        "\n",
        "# Cosine similarity will be dot product because vectors are normalized\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "id": "b79da63b",
      "metadata": {
        "id": "b79da63b"
      },
      "outputs": [],
      "source": [
        "# ============================================================\n",
        "# Cell 6 — Helpers\n",
        "#  * minmax_with_tie_cap: per-query normalization w/ rank fallback\n",
        "#  * fused_score: hybrid fusion\n",
        "#  * exact-match: normalized text equality badge\n",
        "# ============================================================\n",
        "from typing import List\n",
        "import numpy as np\n",
        "\n",
        "def minmax_with_tie_cap(v: List[float], *, eps: float = 1e-9,\n",
        "                        tie_thresh: float = 1e-9,\n",
        "                        use_rank_if_flat: bool = True) -> List[float]:\n",
        "    \"\"\"Min–max to [0,1]; if nearly flat, use rank-based scaling to avoid many 1.0 ties.\"\"\"\n",
        "    if not v:\n",
        "        return []\n",
        "    v = np.asarray(v, dtype=float)\n",
        "    vmin, vmax = float(np.nanmin(v)), float(np.nanmax(v))\n",
        "    rng = vmax - vmin\n",
        "    if not np.isfinite(vmin) or not np.isfinite(vmax) or rng < tie_thresh:\n",
        "        if use_rank_if_flat:\n",
        "            order = np.argsort(-v)  # descending\n",
        "            ranks = np.empty_like(order, dtype=float)\n",
        "            ranks[order] = np.arange(len(v), dtype=float)  # 0..N-1\n",
        "            if len(v) == 1:\n",
        "                out = np.array([1.0], dtype=float)\n",
        "            else:\n",
        "                out = 1.0 - (ranks / (len(v)-1))\n",
        "            return out.tolist()\n",
        "        else:\n",
        "            # tiny jitter\n",
        "            noise = np.linspace(0.0, 1e-4, num=len(v))\n",
        "            return (noise / max(1e-9, noise.max())).tolist()\n",
        "    return ((v - vmin) / max(rng, eps)).tolist()\n",
        "\n",
        "def fused_score(cos_norm: float, bm25_norm: float, alpha: float = 0.8) -> float:\n",
        "    return float(alpha * cos_norm + (1.0 - alpha) * bm25_norm)\n",
        "\n",
        "# Map key -> original Arabic (for exact-match badge)\n",
        "KEY2TXT = dict(zip(df[\"key\"], df[\"arabic_text\"]))\n",
        "def is_identical_text(k1: str, k2: str) -> bool:\n",
        "    if k1 == k2:  # we never show self-link; treat as not \"identical\" badge\n",
        "        return False\n",
        "    return normalize_arabic(KEY2TXT.get(k1, \"\")) == normalize_arabic(KEY2TXT.get(k2, \"\"))\n",
        "\n",
        "    # --- NEW: tokenization helper reused from BM25 ---\n",
        "def simple_tok(s: str):\n",
        "    return [t for t in re.split(r\"\\W+\", s) if t]\n",
        "\n",
        "def jaccard_overlap(a: set, b: set) -> float:\n",
        "    if not a or not b: return 0.0\n",
        "    inter = len(a & b); union = len(a | b)\n",
        "    return inter / union if union else 0.0\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# ============================================================\n",
        "# Cell 7 — Build neighbors (Hybrid + Cosine + BM25) and export\n",
        "#  * Keep raw and normalized values\n",
        "#  * Add \"identical\" and \"overlap\" fields\n",
        "#  * Gate hybrid score by lexical overlap\n",
        "#  * Write three JSONs with meta\n",
        "# ============================================================\n",
        "N = len(df)\n",
        "keys = df[\"key\"].tolist()\n",
        "\n",
        "row_indices = list(range(N))\n",
        "if isinstance(GENERATE_LIMIT, int) and GENERATE_LIMIT > 0:\n",
        "    row_indices = row_indices[:GENERATE_LIMIT]\n",
        "\n",
        "links_hybrid, links_cos, links_bm = {}, {}, {}\n",
        "\n",
        "for i in tqdm(row_indices, desc=\"Building neighbors\"):\n",
        "    # ----- Raw signals -----\n",
        "    cos_raw = emb @ emb[i]                       # raw cosine (dot) per doc\n",
        "    q_tokens = corpus_tokens[i]                  # query = tokens of verse i\n",
        "    q_set = set(q_tokens)\n",
        "    bm25_raw = np.asarray(BM25Okapi.get_scores(bm25, q_tokens), dtype=float)\n",
        "\n",
        "    # Remove self-link\n",
        "    cos_raw[i]  = -1.0\n",
        "    bm25_raw[i] = -np.inf\n",
        "\n",
        "    # ----- Normalized per query (with tie handling) -----\n",
        "    cos_n  = np.asarray(minmax_with_tie_cap(cos_raw.tolist()), dtype=float)\n",
        "    bm25_clamped = np.maximum(bm25_raw, 0.0)      # clamp then scale\n",
        "    bm25_n = np.asarray(minmax_with_tie_cap(bm25_clamped.tolist()), dtype=float)\n",
        "\n",
        "    # ----- Combined hybrid score (with overlap gate) -----\n",
        "    # NOTE: overlap is computed per-candidate below, so gating is applied after we compute it\n",
        "    fused = ALPHA * cos_n + (1.0 - ALPHA) * bm25_n\n",
        "\n",
        "    # ----- Top-K selection by fused score -----\n",
        "    K = min(TOP_K, len(keys) - 1)\n",
        "    top_idx = np.argpartition(-fused, range(K))[:K]\n",
        "    top_idx = top_idx[np.argsort(-fused[top_idx])]\n",
        "\n",
        "    qkey = keys[i]\n",
        "    rows_h, rows_c, rows_b = [], [], []\n",
        "\n",
        "    for j in top_idx:\n",
        "        vkey = keys[j]\n",
        "        cand_tokens = corpus_tokens[j]\n",
        "        overlap = jaccard_overlap(q_set, set(cand_tokens))  # 0..1\n",
        "\n",
        "        # Apply overlap gate here to fused[j]\n",
        "        fused_j = fused[j] * (0.2 + 0.8 * overlap)\n",
        "\n",
        "        rows_h.append({\n",
        "            \"id\": vkey,\n",
        "            \"score\": float(fused_j),\n",
        "            \"cos\": float(cos_n[j]),\n",
        "            \"cos_raw\": float(cos_raw[j]),\n",
        "            \"bm25\": float(bm25_n[j]),\n",
        "            \"bm25_raw\": float(bm25_raw[j]) if np.isfinite(bm25_raw[j]) else 0.0,\n",
        "            \"overlap\": float(overlap),\n",
        "            \"identical\": bool(is_identical_text(qkey, vkey))\n",
        "        })\n",
        "        rows_c.append({\n",
        "            \"id\": vkey,\n",
        "            \"score\": float(cos_n[j]),\n",
        "            \"cos\": float(cos_n[j]),\n",
        "            \"cos_raw\": float(cos_raw[j]),\n",
        "            \"overlap\": float(overlap),\n",
        "            \"identical\": bool(is_identical_text(qkey, vkey))\n",
        "        })\n",
        "        rows_b.append({\n",
        "            \"id\": vkey,\n",
        "            \"score\": float(bm25_n[j]),\n",
        "            \"bm25\": float(bm25_n[j]),\n",
        "            \"bm25_raw\": float(bm25_raw[j]) if np.isfinite(bm25_raw[j]) else 0.0,\n",
        "            \"overlap\": float(overlap),\n",
        "            \"identical\": bool(is_identical_text(qkey, vkey))\n",
        "        })\n",
        "\n",
        "    # Store per-query lists\n",
        "    links_hybrid[qkey] = rows_h\n",
        "    links_cos[qkey]    = rows_c\n",
        "    links_bm[qkey]     = rows_b\n",
        "\n",
        "# ----- Metadata -----\n",
        "meta = {\n",
        "    \"alpha\": float(ALPHA),\n",
        "    \"top_k\": int(TOP_K),\n",
        "    \"gate_overlap\": True,\n",
        "    \"overlap_gate_formula\": \"score *= (0.2 + 0.8*overlap)\",\n",
        "    \"timestamp\": str(datetime.date.today())\n",
        "}\n",
        "\n",
        "def save_with_meta(path: Path, payload: dict):\n",
        "    with open(path, \"w\", encoding=\"utf-8\") as f:\n",
        "        json.dump({\"meta\": meta, **payload}, f, ensure_ascii=False, indent=2)\n",
        "    print(f\"✅ wrote {path} (keys: {len(payload)})\")\n",
        "\n",
        "# ----- Save outputs -----\n",
        "save_with_meta(LINKS_HYBRID, links_hybrid)\n",
        "save_with_meta(LINKS_COSINE, links_cos)\n",
        "save_with_meta(LINKS_BM25,   links_bm)\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "bMihKzDeew0a",
        "outputId": "ec165a94-3235-4dce-98b3-625070b01789"
      },
      "id": "bMihKzDeew0a",
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "Building neighbors: 100%|██████████| 6236/6236 [05:07<00:00, 20.28it/s]\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "✅ wrote /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/links.json (keys: 6236)\n",
            "✅ wrote /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/links_cosine.json (keys: 6236)\n",
            "✅ wrote /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/links_bm25.json (keys: 6236)\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# ============================================================\n",
        "# Cell 8 — Sanity check\n",
        "#  * Confirm non-empty and print a small sample (with raw values)\n",
        "# ============================================================\n",
        "for p in [LINKS_HYBRID, LINKS_COSINE, LINKS_BM25]:\n",
        "    obj = json.loads(p.read_text(encoding=\"utf-8\"))\n",
        "    data = {k:v for k,v in obj.items() if k != \"meta\"}\n",
        "    print(p.name, \"keys:\", len(data))\n",
        "    if data:\n",
        "        k0 = next(iter(data.keys()))\n",
        "        print(\" sample key:\", k0)\n",
        "        print(\" first 2 neighbors:\")\n",
        "        for row in data[k0][:2]:\n",
        "            print(\"  \", {k: row[k] for k in row if k in [\"id\",\"score\",\"cos\",\"cos_raw\",\"bm25\",\"bm25_raw\",\"identical\"]})\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "aWlN9dWKxoHc",
        "outputId": "fba11940-62f4-4fc8-903d-f6a1bc8f81ec"
      },
      "id": "aWlN9dWKxoHc",
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "links.json keys: 6236\n",
            " sample key: 1:1\n",
            " first 2 neighbors:\n",
            "   {'id': '27:30', 'score': 0.6287833933263205, 'cos': 0.9696229611932939, 'cos_raw': 0.9175143837928772, 'bm25': 1.0, 'bm25_raw': 26.871746738245918, 'identical': False}\n",
            "   {'id': '1:3', 'score': 0.6579720658891357, 'cos': 1.0, 'cos_raw': 0.9775876402854919, 'bm25': 0.8380298962436452, 'bm25_raw': 22.51932713093774, 'identical': False}\n",
            "links_cosine.json keys: 6236\n",
            " sample key: 1:1\n",
            " first 2 neighbors:\n",
            "   {'id': '27:30', 'score': 0.9696229611932939, 'cos': 0.9696229611932939, 'cos_raw': 0.9175143837928772, 'identical': False}\n",
            "   {'id': '1:3', 'score': 1.0, 'cos': 1.0, 'cos_raw': 0.9775876402854919, 'identical': False}\n",
            "links_bm25.json keys: 6236\n",
            " sample key: 1:1\n",
            " first 2 neighbors:\n",
            "   {'id': '27:30', 'score': 1.0, 'bm25': 1.0, 'bm25_raw': 26.871746738245918, 'identical': False}\n",
            "   {'id': '1:3', 'score': 0.8380298962436452, 'bm25': 0.8380298962436452, 'bm25_raw': 22.51932713093774, 'identical': False}\n"
          ]
        }
      ]
    },
    {
      "cell_type": "code",
      "source": [
        "# ============================================\n",
        "# Cell 9 — Extended Evaluation Suite (α sweep)\n",
        "#  - Keeps original NDCG/MAP vs α\n",
        "#  - Adds: Precision@K, Recall@K, HitRate@K, MRR@K, R-Precision\n",
        "#  - Adds diagnostics: links coverage, retrievability/union coverage, candidate stats\n",
        "#  - Outputs:\n",
        "#       1) alpha_scores.csv  (all metrics by α)\n",
        "#       2) alpha_ndcg_map.png (plot)\n",
        "#       3) evaluation_report.txt (single, readable report with diagnostics)\n",
        "# ============================================\n",
        "\n",
        "import os, re, json, csv, math, statistics as stats\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from typing import Dict, List, Tuple\n",
        "from pathlib import Path\n",
        "\n",
        "# --------- CONFIG ----------\n",
        "USE_GOOGLE_DRIVE = True\n",
        "GDRIVE_GOLD_DIR  = \"/content/drive/My Drive/999. MS/10. Project/quran_semantic_data\"\n",
        "GOLDEN_CANDIDATES = [\n",
        "    \"golden_clean.csv\",            # if you created a cleaned file earlier\n",
        "    \"golden (061100 Nov 25).csv\",  # your uploaded name\n",
        "    \"golden.csv\",\n",
        "]\n",
        "SEARCH_DIRS = [Path.cwd(), Path(GDRIVE_GOLD_DIR), Path(\"/mnt/data\")]\n",
        "ALPHAS = [x/10 for x in range(1,11)]   # 0.1..1.0\n",
        "K      = 20\n",
        "PLOT_ALPHA_MARKERS = True  # show points on curves\n",
        "\n",
        "# --------- Drive (soft mount) ----------\n",
        "if USE_GOOGLE_DRIVE:\n",
        "    try:\n",
        "        from google.colab import drive\n",
        "        drive.mount(\"/content/drive\", force_remount=False)\n",
        "    except Exception as e:\n",
        "        print(\"Drive mount note:\", e)\n",
        "\n",
        "# --------- Helpers ----------\n",
        "_key_re = re.compile(r'^[1-9]\\d*:[1-9]\\d*$')\n",
        "\n",
        "def _norm_key(s: str) -> str:\n",
        "    \"\"\"Normalize to 'S:A' (remove quotes/spaces/leading zeros on both sides).\"\"\"\n",
        "    s = (str(s) if s is not None else \"\").strip()\n",
        "    s = s.replace('\"','').replace(\"'\",\"\").replace(\" \", \"\")\n",
        "    m = re.match(r'^0*([1-9]\\d*)\\s*:\\s*0*([1-9]\\d*)$', s)\n",
        "    return f\"{int(m.group(1))}:{int(m.group(2))}\" if m else s\n",
        "\n",
        "def parse_rel_list(s: str) -> Dict[str, float]:\n",
        "    \"\"\"Parse '2:153|3:200|2:286(2)' -> {'2:153':1.0,'3:200':1.0,'2:286':2.0} (normalized).\"\"\"\n",
        "    out = {}\n",
        "    if not s: return out\n",
        "    for chunk in str(s).split('|'):\n",
        "        c = (chunk or \"\").strip()\n",
        "        if not c:\n",
        "            continue\n",
        "        if '(' in c and c.endswith(')'):\n",
        "            try:\n",
        "                key, g = c[:-1].split('(')\n",
        "                out[_norm_key(key)] = float(g)\n",
        "            except Exception:\n",
        "                out[_norm_key(c)] = 1.0\n",
        "        else:\n",
        "            out[_norm_key(c)] = 1.0\n",
        "    # keep only well-formed ids\n",
        "    return {k:v for k,v in out.items() if _key_re.match(k)}\n",
        "\n",
        "def find_file(filename_candidates, search_dirs):\n",
        "    for d in search_dirs:\n",
        "        for cand in filename_candidates:\n",
        "            p = d / cand\n",
        "            if p.exists(): return p\n",
        "            for g in d.glob(cand):\n",
        "                if g.exists(): return g\n",
        "    return None\n",
        "\n",
        "def normalize_links_obj(raw: dict, mode: str) -> Dict[str, List[dict]]:\n",
        "    \"\"\"Return { 's:a': [ {id, cos?, bm25?, score?} ] }, tolerating your JSON shapes.\"\"\"\n",
        "    def nkey(x):\n",
        "        return _norm_key(x) if x is not None else \"\"\n",
        "    src = {k:v for k,v in raw.items() if k != 'meta'}\n",
        "    out = {}\n",
        "    for k, arr in src.items():\n",
        "        kk = nkey(k)\n",
        "        if not _key_re.match(kk):\n",
        "            continue\n",
        "        rows = []\n",
        "        if isinstance(arr, list):\n",
        "            for e in arr:\n",
        "                if isinstance(e, dict):\n",
        "                    vid = nkey(e.get('id') or e.get('key') or '')\n",
        "                    if not _key_re.match(vid) or vid == kk:\n",
        "                        continue\n",
        "                    cos = e.get('cos'); bm = e.get('bm25') or e.get('bm')\n",
        "                    sc  = e.get('score')\n",
        "                    if sc is None:\n",
        "                        sc = cos if mode == 'cosine' else (bm if mode == 'bm25' else None)\n",
        "                    rows.append({'id': vid, 'cos': cos, 'bm25': bm, 'score': sc})\n",
        "                elif isinstance(e, list) and e:\n",
        "                    vid = nkey(e[0]); sc = float(e[1]) if len(e)>1 else 0.0\n",
        "                    if not _key_re.match(vid) or vid == kk:\n",
        "                        continue\n",
        "                    if mode == 'cosine':\n",
        "                        rows.append({'id': vid, 'cos': sc, 'bm25': 0.0, 'score': sc})\n",
        "                    else:\n",
        "                        sc = max(0.0, sc)\n",
        "                        rows.append({'id': vid, 'cos': 0.0, 'bm25': sc, 'score': sc})\n",
        "        rows.sort(key=lambda x: (x.get('score') or 0), reverse=True)\n",
        "        out[kk] = rows\n",
        "    return out\n",
        "\n",
        "def load_links_json(path_cos: Path, path_bm25: Path):\n",
        "    cos_raw = json.loads(path_cos.read_text(encoding='utf-8'))\n",
        "    bm_raw  = json.loads(path_bm25.read_text(encoding='utf-8'))\n",
        "    return normalize_links_obj(cos_raw, 'cosine'), normalize_links_obj(bm_raw, 'bm25')\n",
        "\n",
        "def fused_ranking_for_query(cos_rows: List[dict], bm_rows: List[dict], alpha: float, k: int) -> List[str]:\n",
        "    \"\"\"Union of candidates; score = α·cos + (1-α)·bm25.\"\"\"\n",
        "    scores = {}\n",
        "    for row in cos_rows:\n",
        "        vid = row['id']; c = float(row.get('cos') or row.get('score') or 0.0)\n",
        "        scores[vid] = max(scores.get(vid, 0.0), alpha * c)\n",
        "    for row in bm_rows:\n",
        "        vid = row['id']; b = float(row.get('bm25') or row.get('score') or 0.0)\n",
        "        scores[vid] = scores.get(vid, 0.0) + (1.0 - alpha) * b\n",
        "    ranked = sorted(scores.items(), key=lambda kv: kv[1], reverse=True)\n",
        "    return [vid for vid,_ in ranked[:k]]\n",
        "\n",
        "# --------- Metrics (binary use rel>0; graded used in NDCG) ----------\n",
        "def dcg_at_k(rels: List[float], k: int) -> float:\n",
        "    return sum((rel / math.log2(i+2)) for i, rel in enumerate(rels[:k]))\n",
        "\n",
        "def ndcg_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    gains = [rel_dict.get(v, 0.0) for v in pred_ids[:k]]\n",
        "    dcg = dcg_at_k(gains, k)\n",
        "    ideal = sorted(rel_dict.values(), reverse=True)\n",
        "    idcg = dcg_at_k(ideal, min(k, len(ideal))) if ideal else 0.0\n",
        "    return (dcg / idcg) if idcg > 0 else 0.0\n",
        "\n",
        "def map_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    hits = 0; ap_sum = 0.0\n",
        "    total_pos = sum(1 for v in rel_dict.values() if v > 0)\n",
        "    if total_pos == 0: return 0.0\n",
        "    for i, vid in enumerate(pred_ids[:k], start=1):\n",
        "        if rel_dict.get(vid, 0.0) > 0:\n",
        "            hits += 1\n",
        "            ap_sum += hits / i\n",
        "    return ap_sum / total_pos\n",
        "\n",
        "def precision_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    if k == 0: return 0.0\n",
        "    hits = sum(1 for vid in pred_ids[:k] if rel_dict.get(vid, 0.0) > 0)\n",
        "    return hits / k\n",
        "\n",
        "def recall_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    total_pos = sum(1 for v in rel_dict.values() if v > 0)\n",
        "    if total_pos == 0: return 0.0\n",
        "    hits = sum(1 for vid in pred_ids[:k] if rel_dict.get(vid, 0.0) > 0)\n",
        "    return hits / total_pos\n",
        "\n",
        "def hitrate_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    return 1.0 if any(rel_dict.get(vid, 0.0) > 0 for vid in pred_ids[:k]) else 0.0\n",
        "\n",
        "def mrr_at_k(pred_ids: List[str], rel_dict: Dict[str, float], k: int) -> float:\n",
        "    for i, vid in enumerate(pred_ids[:k], start=1):\n",
        "        if rel_dict.get(vid, 0.0) > 0:\n",
        "            return 1.0 / i\n",
        "    return 0.0\n",
        "\n",
        "def r_precision(pred_ids: List[str], rel_dict: Dict[str, float]) -> float:\n",
        "    R = sum(1 for v in rel_dict.values() if v > 0)\n",
        "    if R == 0: return 0.0\n",
        "    top = pred_ids[:R]\n",
        "    hits = sum(1 for vid in top if rel_dict.get(vid, 0.0) > 0)\n",
        "    return hits / R\n",
        "\n",
        "# --------- Resolve golden.csv ----------\n",
        "gold_dir = Path(GDRIVE_GOLD_DIR) if USE_GOOGLE_DRIVE else Path.cwd()\n",
        "gold_path = None\n",
        "\n",
        "for name in GOLDEN_CANDIDATES:\n",
        "    p = gold_dir / name\n",
        "    if p.exists(): gold_path = p; break\n",
        "if gold_path is None and gold_dir.exists():\n",
        "    matches = sorted(gold_dir.glob(\"golden*.csv\"))\n",
        "    if matches: gold_path = matches[0]\n",
        "if gold_path is None:\n",
        "    mnt_matches = sorted(Path(\"/mnt/data\").glob(\"golden*.csv\"))\n",
        "    if mnt_matches: gold_path = mnt_matches[0]\n",
        "\n",
        "assert gold_path and gold_path.exists(), (\n",
        "    f\"Golden set not found. Looked in {GDRIVE_GOLD_DIR} and /mnt/data.\"\n",
        ")\n",
        "print(\"Using golden CSV:\", gold_path)\n",
        "\n",
        "# --------- Load & CLEAN golden.csv ----------\n",
        "import pandas as pd\n",
        "raw = pd.read_csv(gold_path)\n",
        "cols = {c.strip().lower(): c for c in raw.columns}\n",
        "assert \"query_id\" in cols and \"positives\" in cols, f\"CSV must have columns: query_id, positives; got {list(raw.columns)}\"\n",
        "\n",
        "raw[\"query_id\"]  = raw[cols[\"query_id\"]].map(_norm_key)\n",
        "raw[\"positives\"] = raw[cols[\"positives\"]].astype(str)\n",
        "raw = raw.dropna(subset=[\"query_id\",\"positives\"]).reset_index(drop=True)\n",
        "\n",
        "# Expand into dict: q -> {id:grade,...}\n",
        "gold: Dict[str, Dict[str, float]] = {}\n",
        "for _, r in raw.iterrows():\n",
        "    q  = r[\"query_id\"]\n",
        "    rs = parse_rel_list(r[\"positives\"])\n",
        "    if _key_re.match(q) and rs:\n",
        "        gold[q] = rs\n",
        "\n",
        "if not gold:\n",
        "    raise AssertionError(\n",
        "        \"After cleaning, your golden set has no valid rows.\\n\"\n",
        "        \"Check for empty 'positives' cells or malformed verse IDs.\"\n",
        "    )\n",
        "\n",
        "# --------- Find links files ----------\n",
        "def find_first(patterns: List[str]) -> Path:\n",
        "    for d in SEARCH_DIRS:\n",
        "        for pat in patterns:\n",
        "            for m in d.glob(pat):\n",
        "                if m.exists():\n",
        "                    return m\n",
        "    return None\n",
        "\n",
        "links_cos = find_first([\"links_cosine.json\", \"links_cos*.json\"])\n",
        "links_bm  = find_first([\"links_bm25.json\",  \"links_bm*.json\"])\n",
        "assert links_cos and links_cos.exists(), \"links_cosine.json not found in search dirs.\"\n",
        "assert links_bm  and links_bm.exists(),  \"links_bm25.json not found in search dirs.\"\n",
        "print(\"Using links_cosine:\", links_cos)\n",
        "print(\"Using links_bm25 :\", links_bm)\n",
        "\n",
        "# --------- Load links & diagnostics ----------\n",
        "cos_map, bm_map = load_links_json(links_cos, links_bm)\n",
        "cos_keys = set(cos_map.keys()); bm_keys = set(bm_map.keys()); any_keys = cos_keys | bm_keys\n",
        "\n",
        "missing_q = [q for q in gold.keys() if q not in any_keys]\n",
        "covered_q = [q for q in gold.keys() if q in any_keys]\n",
        "links_coverage = len(covered_q) / max(1, len(gold))\n",
        "\n",
        "# Per-query union coverage of positives (retrievability)\n",
        "def union_candidates(qid: str) -> set:\n",
        "    cset = set(e['id'] for e in cos_map.get(qid, []))\n",
        "    bset = set(e['id'] for e in bm_map.get(qid, []))\n",
        "    return cset | bset\n",
        "\n",
        "retrievability = []\n",
        "cand_len_stats = []  # (len_cos, len_bm, len_union)\n",
        "for qid in covered_q:\n",
        "    u = union_candidates(qid)\n",
        "    rel_ids = {vid for vid, g in gold[qid].items() if g > 0}\n",
        "    if rel_ids:\n",
        "        retrievability.append(len(rel_ids & u) / len(rel_ids))\n",
        "    cand_len_stats.append( (len(cos_map.get(qid, [])), len(bm_map.get(qid, [])), len(u)) )\n",
        "\n",
        "avg_cos_cands = float(np.mean([c for c,_,_ in cand_len_stats])) if cand_len_stats else 0.0\n",
        "avg_bm_cands  = float(np.mean([b for _,b,_ in cand_len_stats])) if cand_len_stats else 0.0\n",
        "avg_u_cands   = float(np.mean([u for *_,u in cand_len_stats]))  if cand_len_stats else 0.0\n",
        "mean_retrievability = float(np.mean(retrievability)) if retrievability else 0.0\n",
        "\n",
        "print(f\"Gold queries total: {len(gold)} | Covered by links: {len(covered_q)} \"\n",
        "      f\"({links_coverage*100:.1f}%)\")\n",
        "if missing_q:\n",
        "    print(f\"⚠️ {len(missing_q)} gold queries missing in links (showing up to 8): {missing_q[:8]}\")\n",
        "print(f\"Avg candidate lengths — cosine: {avg_cos_cands:.1f}, bm25: {avg_bm_cands:.1f}, union: {avg_u_cands:.1f}\")\n",
        "print(f\"Retrievability (union of cosine+bm25 contains gold positives): {mean_retrievability*100:.1f}%\")\n",
        "\n",
        "# --------- Evaluation over α ----------\n",
        "def evaluate_for_alpha(a: float) -> Tuple[float,float,float,float,float,float,float,int]:\n",
        "    nds, mps, prs, rcs, hits, mrrs, rps = [], [], [], [], [], [], []\n",
        "    used = 0\n",
        "    for qid in covered_q:\n",
        "        rels     = gold[qid]\n",
        "        cos_rows = cos_map.get(qid, [])\n",
        "        bm_rows  = bm_map.get(qid, [])\n",
        "        if not cos_rows and not bm_rows:\n",
        "            continue\n",
        "        pred = fused_ranking_for_query(cos_rows, bm_rows, a, K)\n",
        "        nds.append(ndcg_at_k(pred, rels, K))\n",
        "        mps.append(map_at_k(pred, rels, K))\n",
        "        prs.append(precision_at_k(pred, rels, K))\n",
        "        rcs.append(recall_at_k(pred, rels, K))\n",
        "        hits.append(hitrate_at_k(pred, rels, K))\n",
        "        mrrs.append(mrr_at_k(pred, rels, K))\n",
        "        rps.append(r_precision(pred, rels))\n",
        "        used += 1\n",
        "    if used == 0:\n",
        "        return (0,)*7 + (0,)\n",
        "    return (\n",
        "        float(np.mean(nds)),\n",
        "        float(np.mean(mps)),\n",
        "        float(np.mean(prs)),\n",
        "        float(np.mean(rcs)),\n",
        "        float(np.mean(hits)),\n",
        "        float(np.mean(mrrs)),\n",
        "        float(np.mean(rps)),\n",
        "        used\n",
        "    )\n",
        "\n",
        "rows = []\n",
        "for a in ALPHAS:\n",
        "    row = evaluate_for_alpha(a)\n",
        "    rows.append((a, *row))\n",
        "\n",
        "# --------- Save CSV ----------\n",
        "out_csv  = gold_path.parent / \"alpha_scores.csv\"\n",
        "with out_csv.open(\"w\", encoding=\"utf-8\", newline=\"\") as f:\n",
        "    w = csv.writer(f)\n",
        "    w.writerow([\"alpha\",\"NDCG@K\",\"MAP@K\",\"P@K\",\"R@K\",\"HitRate@K\",\"MRR@K\",\"R-Prec\",\"K\",\"num_queries\"])\n",
        "    for a, nd, mp, pr, rc, hr, mrr, rp, used in rows:\n",
        "        w.writerow([a, f\"{nd:.6f}\", f\"{mp:.6f}\", f\"{pr:.6f}\", f\"{rc:.6f}\",\n",
        "                    f\"{hr:.6f}\", f\"{mrr:.6f}\", f\"{rp:.6f}\", K, used])\n",
        "\n",
        "# --------- Plot (NDCG & MAP vs α) ----------\n",
        "out_plot = gold_path.parent / \"alpha_ndcg_map.png\"\n",
        "xs = [a for a,*_ in rows]\n",
        "nd = [v for _,v, *_ in rows]\n",
        "mp = [v for _,_,v, *_ in rows]\n",
        "plt.figure()\n",
        "plt.plot(xs, nd, marker='o' if PLOT_ALPHA_MARKERS else None, label=f'NDCG@{K}')\n",
        "plt.plot(xs, mp, marker='s' if PLOT_ALPHA_MARKERS else None, label=f'MAP@{K}')\n",
        "plt.xlabel(\"Alpha (α)\"); plt.ylabel(\"Score\"); plt.title(f\"NDCG & MAP vs α (K={K})\")\n",
        "plt.grid(True, linestyle='--', alpha=0.5)\n",
        "plt.legend(); plt.tight_layout(); plt.savefig(out_plot, dpi=160)\n",
        "\n",
        "# --------- Human-readable report ----------\n",
        "best_ndcg_idx = int(np.argmax(nd)) if xs else 0\n",
        "best_map_idx  = int(np.argmax(mp)) if xs else 0\n",
        "\n",
        "def fmt(x):\n",
        "    return f\"{x:.4f}\"\n",
        "\n",
        "report_lines = []\n",
        "report_lines.append(\"=== Hybrid Evaluation Report ===\")\n",
        "report_lines.append(f\"Golden CSV: {gold_path.name}\")\n",
        "report_lines.append(f\"Links: cosine={links_cos.name}, bm25={links_bm.name}\")\n",
        "report_lines.append(\"\")\n",
        "report_lines.append(f\"Gold queries: {len(gold)} | Covered in links: {len(covered_q)} ({links_coverage*100:.1f}%)\")\n",
        "if missing_q:\n",
        "    report_lines.append(f\"Missing gold queries in links (up to 8): {missing_q[:8]}\")\n",
        "report_lines.append(f\"Avg candidate sizes — cosine: {avg_cos_cands:.1f}, bm25: {avg_bm_cands:.1f}, union: {avg_u_cands:.1f}\")\n",
        "report_lines.append(f\"Retrievability (union contains gold positives): {mean_retrievability*100:.1f}%\")\n",
        "report_lines.append(\"\")\n",
        "report_lines.append(f\"Top-line (best over α):\")\n",
        "report_lines.append(f\"  Best α by NDCG: {xs[best_ndcg_idx]:.2f}  (NDCG={fmt(nd[best_ndcg_idx])})\")\n",
        "report_lines.append(f\"  Best α by MAP : {xs[best_map_idx]:.2f}  (MAP ={fmt(mp[best_map_idx])})\")\n",
        "report_lines.append(\"\")\n",
        "report_lines.append(\"Per-α summary (means over covered queries):\")\n",
        "hdr = \"  α     NDCG   MAP    P@K    R@K    Hit@K  MRR@K  R-Prec\"\n",
        "report_lines.append(hdr)\n",
        "for a, nd_, mp_, pr_, rc_, hr_, mrr_, rp_, used in rows:\n",
        "    report_lines.append(f\"  {a:0.1f}  {fmt(nd_)} {fmt(mp_)} {fmt(pr_)} {fmt(rc_)} {fmt(hr_)} {fmt(mrr_)} {fmt(rp_)}\")\n",
        "\n",
        "out_report = gold_path.parent / \"evaluation_report.txt\"\n",
        "out_report.write_text(\"\\n\".join(report_lines), encoding=\"utf-8\")\n",
        "\n",
        "print(\"\\n\".join(report_lines))\n",
        "print(\"\\nSaved:\")\n",
        "print(\"  CSV  :\", out_csv)\n",
        "print(\"  Plot :\", out_plot)\n",
        "print(\"  Report:\", out_report)\n"
      ],
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 1000
        },
        "id": "GCo-iOZqdsxT",
        "outputId": "a988d80e-2e53-4224-ccdf-7708826cbf51"
      },
      "id": "GCo-iOZqdsxT",
      "execution_count": null,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Drive already mounted at /content/drive; to attempt to forcibly remount, call drive.mount(\"/content/drive\", force_remount=True).\n",
            "Using golden CSV: /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/golden (061100 Nov 25).csv\n",
            "Using links_cosine: /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/links_cosine.json\n",
            "Using links_bm25 : /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/links_bm25.json\n",
            "Gold queries total: 356 | Covered by links: 356 (100.0%)\n",
            "Avg candidate lengths — cosine: 20.0, bm25: 20.0, union: 20.0\n",
            "Retrievability (union of cosine+bm25 contains gold positives): 100.0%\n",
            "=== Hybrid Evaluation Report ===\n",
            "Golden CSV: golden (061100 Nov 25).csv\n",
            "Links: cosine=links_cosine.json, bm25=links_bm25.json\n",
            "\n",
            "Gold queries: 356 | Covered in links: 356 (100.0%)\n",
            "Avg candidate sizes — cosine: 20.0, bm25: 20.0, union: 20.0\n",
            "Retrievability (union contains gold positives): 100.0%\n",
            "\n",
            "Top-line (best over α):\n",
            "  Best α by NDCG: 0.80  (NDCG=0.9979)\n",
            "  Best α by MAP : 0.80  (MAP =0.9972)\n",
            "\n",
            "Per-α summary (means over covered queries):\n",
            "  α     NDCG   MAP    P@K    R@K    Hit@K  MRR@K  R-Prec\n",
            "  0.1  0.9967 0.9956 0.1913 1.0000 1.0000 0.9953 0.9930\n",
            "  0.2  0.9967 0.9956 0.1913 1.0000 1.0000 0.9953 0.9930\n",
            "  0.3  0.9971 0.9960 0.1913 1.0000 1.0000 0.9958 0.9930\n",
            "  0.4  0.9971 0.9960 0.1913 1.0000 1.0000 0.9958 0.9930\n",
            "  0.5  0.9971 0.9960 0.1913 1.0000 1.0000 0.9958 0.9930\n",
            "  0.6  0.9971 0.9960 0.1913 1.0000 1.0000 0.9958 0.9930\n",
            "  0.7  0.9971 0.9960 0.1913 1.0000 1.0000 0.9958 0.9930\n",
            "  0.8  0.9979 0.9972 0.1913 1.0000 1.0000 0.9972 0.9944\n",
            "  0.9  0.9969 0.9958 0.1913 1.0000 1.0000 0.9958 0.9916\n",
            "  1.0  0.9937 0.9915 0.1913 1.0000 1.0000 0.9902 0.9850\n",
            "\n",
            "Saved:\n",
            "  CSV  : /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/alpha_scores.csv\n",
            "  Plot : /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/alpha_ndcg_map.png\n",
            "  Report: /content/drive/My Drive/999. MS/10. Project/quran_semantic_data/evaluation_report.txt\n"
          ]
        },
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 640x480 with 1 Axes>"
            ],
            "image/png": "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jmHd5uIf//gHH330Eb179+bkyZOXvA27YsUKysrK6N69O0eOHLGX9+nThw8//LDSxO7zzz+nSZMmeHp60rJlS+Li4qptV2hoKDfccAOffvopzzzzjP3cHh4ejBw50l7v6aefZtiwYbRr144uXbowePBg7rzzTi6//PJLHv/UqVMMGDCgXFn37t0Bqh2tu1BVt8Pbtm3LuHHjePTRR7n11lv57LPPKp2z2LNnT4fPVZXp06ezdu1aPvjgA7p27Vrua76+vpSUlFR4jW1LE19f33Lltv5cat6gEFoniZ0QDVhsbCx33HGHfdSuNvbu3QtYf1kDdOjQAYA9e/Zc8nai7TUeHh72Y1zommuuAcDDw7G3oc2bN9vnloE10cvIyGDGjBkEBgYSERFBamoqt99+u0PHs7ntttt46623eOqpp+jatSudOnWqsq5tLl1ViwuOHj1qv51nM2DAgCpvRV7K2LFjmTBhArt376Zbt258+umn3HDDDeWONWDAAJKSklizZg3fffcd7777Lv/5z3946623mDhxYpXH9vHxqZC82JL0ixO+ytjmB15qtO2RRx4hKyuL+fPnM2nSJBYvXlzhnNnZ2ZSWllZ7Pl9fX4KCgiqUz5kzhzfeeIPnn3++0jmftp+Ji6WlpQEVRwJt/alNvITQClk8IUQDN3v2bEwmEy+88EKNX1tQUMDq1auJjo6mY8eOwPkRnao2972Qv78/1157LZs2bar0F2xNKIpSYRXja6+9xujRo7n33nu5//77GT58uH3kyVFXXXUVrVq1YuPGjZccrUtOTmbz5s1MmzaNzz77rNy/FStW4OXlVa97oA0fPhwvLy9WrFjB7t27OXToUKWjkc2aNWPChAl8/PHHnDx5kssvv7zc7enKREdHc+LEiXJlX331FYBDcbIl91Wt7LV54YUXmDhxIu+9916lo7IjR44kIiKi2n8X3n62WbhwIU899RQPPvggjz76aKXn79atG4cOHaqwIbRt4+1u3bqVK7f1x/azLoQeyYidEA1cXFwcd9xxB2+//TatW7d2eISsqKiIO++8k+zsbJ577jn7aEu/fv0YPHgw7777LjfddBPDhw8v97rS0lL+/e9/27c8eeKJJ7j22mu54447+OqrryrMt3N0devAgQP54osv2LRpk320z2Aw8O677/Ljjz9y4sQJnn76aYeOdSFFUfjv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\n"
          },
          "metadata": {}
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": [],
      "gpuType": "T4"
    },
    "language_info": {
      "name": "python"
    },
    "kernelspec": {
      "name": "python3",
      "display_name": "Python 3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
